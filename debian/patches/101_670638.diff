# ftp://invisible-island.net/temp/xterm-278-p3.patch.gz
# patch by Thomas E. Dickey <dickey@invisible-island.net>
# created  Tue Nov 27 10:17:15 UTC 2012
# ------------------------------------------------------------------------------
# misc.c |   90 ++++++++++++++++++++++++++++++++++++++++++++++++++++++---------
# 1 file changed, 78 insertions(+), 12 deletions(-)
# ------------------------------------------------------------------------------
Index: misc.c
--- xterm-278+/misc.c	2012-01-07 01:57:52.000000000 +0000
+++ xterm-278-p3/misc.c	2012-11-27 10:10:36.000000000 +0000
@@ -2176,16 +2176,79 @@
 #define ULONG_MAX (unsigned long)(~(0L))
 #endif
 
-static unsigned short
-searchColortable(XColor * colortable, unsigned length, unsigned color)
+#define CheckColor(result, value) \
+	    result = 0; \
+	    if (value.red) \
+		result |= 1; \
+	    if (value.green) \
+		result |= 2; \
+	    if (value.blue) \
+		result |= 4
+
+#define SelectColor(state, value, result) \
+	switch (state) { \
+	default: \
+	case 1: \
+	    result = value.red; \
+	    break; \
+	case 2: \
+	    result = value.green; \
+	    break; \
+	case 4: \
+	    result = value.blue; \
+	    break; \
+	}
+
+/*
+ * Check if the color map consists of values in exactly one of the red, green
+ * or blue columns.  If it is not, we do not know how to use it for the exact
+ * match.
+ */
+static int
+simpleColors(XColor * colortable, unsigned length)
+{
+    unsigned n;
+    int state = -1;
+    int check;
+
+    for (n = 0; n < length; ++n) {
+	if (state == -1) {
+	    CheckColor(state, colortable[n]);
+	    if (state == 0)
+		state = -1;
+	}
+	if (state > 0) {
+	    CheckColor(check, colortable[n]);
+	    if (check > 0 && check != state) {
+		state = 0;
+		break;
+	    }
+	}
+    }
+    switch (state) {
+    case 1:
+    case 2:
+    case 4:
+	break;
+    default:
+	state = 0;
+	break;
+    }
+    return state;
+}
+
+static unsigned
+searchColors(XColor * colortable, unsigned length, unsigned color, int state)
 {
     unsigned result = 0;
     unsigned n;
     unsigned long best = ULONG_MAX;
     unsigned long diff;
+    unsigned value;
 
     for (n = 0; n < length; ++n) {
-	diff = (color - colortable[n].blue);
+	SelectColor(state, colortable[n], value);
+	diff = (color - value);
 	diff *= diff;
 	if (diff < best) {
 #if 0
@@ -2200,7 +2263,8 @@
 	    best = diff;
 	}
     }
-    return colortable[result].blue;
+    SelectColor(state, colortable[result], value);
+    return value;
 }
 
 /*
@@ -2243,20 +2307,19 @@
     if (result) {
 	unsigned cmap_type;
 	unsigned cmap_size;
+	int state;
 
 	getColormapInfo(screen->display, &cmap_type, &cmap_size);
 
 	if ((cmap_type & 1) == 0) {
 	    XColor temp = *def;
 
-	    if (loadColorTable(xw, cmap_size)) {
-		/*
-		 * Note: the query will return only a value in the ".blue"
-		 * member, leaving ".red" and ".green" as zeros.
-		 */
-		temp.red = searchColortable(screen->cmap_data, cmap_size, save.red);
-		temp.green = searchColortable(screen->cmap_data, cmap_size, save.green);
-		temp.blue = searchColortable(screen->cmap_data, cmap_size, save.blue);
+	    if (loadColorTable(xw, cmap_size)
+		&& (state = simpleColors(screen->cmap_data, cmap_size)) > 0) {
+#define SearchColors(which) temp.which = (unsigned short) searchColors(screen->cmap_data, cmap_size, save.which, state)
+		SearchColors(red);
+		SearchColors(green);
+		SearchColors(blue);
 		if (XAllocColor(screen->display, cmap, &temp) != 0) {
 #if OPT_TRACE
 		    if (temp.red != save.red
@@ -2265,6 +2328,9 @@
 			TRACE(("...improved %x/%x/%x ->%x/%x/%x\n",
 			       save.red, save.green, save.blue,
 			       temp.red, temp.green, temp.blue));
+		    } else {
+			TRACE(("...no improvement for %x/%x/%x\n",
+			       save.red, save.green, save.blue));
 		    }
 #endif
 		    *def = temp;
